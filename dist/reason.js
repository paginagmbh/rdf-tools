// Generated by CoffeeScript 2.3.1
(function() {
  var N3, args, cb, cidocCrm, crm, defaultArgs, err, format, miss, namedNode, ontology, owl, path, quad, to;

  path = require("path");

  miss = require("mississippi");

  N3 = require("n3");

  ({namedNode, quad} = N3.DataFactory);

  defaultArgs = {
    format: "N-Quads"
  };

  args = (require("minimist"))(process.argv.slice(2));

  ({format} = {...defaultArgs, ...args});

  [ontology] = args._;

  if (!ontology) {
    process.exit(2);
  }

  owl = require("./owl");

  crm = require("./cidoc-crm");

  to = miss.pipeline.obj(N3.StreamWriter({format}), process.stdout);

  cb = function(err) {
    if (err != null) {
      console.error(err);
    }
    return process.exitCode = err != null ? 1 : 0;
  };

  cidocCrm = async function() {
    var reasoner, source, target;
    ontology = (await new Promise(function(resolve, reject) {
      return miss.pipe(crm.stream(), crm.parsed(), owl.model(resolve), miss.to.obj(function(triple, _, next) {
        return next();
      }), function(err) {
        if (err != null) {
          return reject(err);
        }
      });
    }));
    source = N3.StreamParser();
    target = N3.StreamWriter({format});
    reasoner = miss.duplex.obj(target, source);
    reasoner.on("data", function(stmt, _, next) {
      var graph, inverse, object, predicate, ref, results, subject;
      ({subject, predicate, object, graph} = stmt);
      results = [];
      for (inverse in (ref = ontology.inversed[predicate.value]) != null ? ref : {}) {
        inverse = namedNode(inverse);
        results.push(reasoner.write(quad(object, inverse, subject, graph)));
      }
      return results;
    });
    miss.pipe(process.stdin, source, cb);
    return miss.pipe(target, process.stdout, cb);
  };

  try {
    switch (ontology) {
      case "cidoc-crm":
        cidocCrm();
        break;
      default:
        cb(`Unknown ontology: ${ontology}`);
    }
  } catch (error) {
    err = error;
    cb(err);
  }

}).call(this);

//# sourceMappingURL=reason.js.map
